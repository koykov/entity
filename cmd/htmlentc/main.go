package main

import (
	"bytes"
	"encoding/json"
	"flag"
	"fmt"
	"go/format"
	"io"
	"io/ioutil"
	"log"
	"net/http"
	"os"
	"sort"

	"github.com/koykov/entry"
)

type entities map[string]struct {
	Codepoints []int  `json:"codepoints"`
	Characters string `json:"characters"`
}

var (
	fsrc = flag.String("source", "", "URL to entities source file.")

	raw   entities
	names []string
)

func init() {
	flag.Parse()

	src := *fsrc
	if len(src) == 0 {
		log.Fatalln("empty source")
	}
	resp, err := http.Get(src)
	if err != nil {
		log.Fatalln(err)
	}
	defer func() { _ = resp.Body.Close() }()

	contents, err := io.ReadAll(resp.Body)
	if err != nil {
		log.Fatalln(err)
	}

	if err = json.Unmarshal(contents, &raw); err != nil {
		log.Fatalln(err)
	}

	for name := range raw {
		names = append(names, name)
	}
	sort.Strings(names)
}

func main() {
	var (
		w   bytes.Buffer
		buf []byte
	)
	_, _ = w.WriteString("// Code generated by \"")
	for i := 0; i < len(os.Args); i++ {
		if i > 0 {
			w.WriteByte(' ')
		}
		w.WriteString(os.Args[i])
	}
	_, _ = w.WriteString("\". DO NOT EDIT.\n\n")
	_, _ = w.WriteString("package htmlent\n\n")

	_, _ = w.WriteString("import \"github.com/koykov/entry\"\n\n")

	_, _ = w.WriteString("var (\n")

	_, _ = w.WriteString("__n2c = map[string]entry.Entry32{\n")
	for i := 0; i < len(names); i++ {
		_, _ = w.WriteString(`"`)
		_, _ = w.WriteString(names[i])
		_, _ = w.WriteString(`":`)
		var e entry.Entry32
		lo := len(buf)
		buf = append(buf, raw[names[i]].Characters...)
		hi := len(buf)
		e.Encode(uint16(lo), uint16(hi))
		_, _ = w.WriteString(fmt.Sprintf("0x%08x", e))
		_, _ = w.WriteString(",\n")
	}
	_, _ = w.WriteString("}\n")

	_, _ = w.WriteString("__buf = []byte{\n")
	for i := 0; i < len(buf); i++ {
		if i > 0 && i%16 == 0 {
			_ = w.WriteByte('\n')
		}
		_, _ = w.WriteString(fmt.Sprintf("0x%02x, ", buf[i]))
	}
	_, _ = w.WriteString("\n}\n")

	_, _ = w.WriteString(")\n")

	source := w.Bytes()
	var (
		fmtSource []byte
		err       error
	)
	if fmtSource, err = format.Source(source); err != nil {
		log.Fatalln(err)
	}

	if err = ioutil.WriteFile("repo.go", fmtSource, 0644); err != nil {
		log.Fatalln(err)
	}
}
