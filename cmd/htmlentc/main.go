package main

import (
	"bytes"
	"encoding/json"
	"flag"
	"fmt"
	"go/format"
	"io"
	"log"
	"net/http"
	"os"
	"sort"
)

const source = "https://html.spec.whatwg.org/entities.json"

type entities map[string]struct {
	Codepoints []int  `json:"codepoints"`
	Characters string `json:"characters"`
}

var (
	fsrc = flag.String("source", "", "URL to entities source file.")

	raw   entities
	names []string
)

func init() {
	src := source
	if len(*fsrc) > 0 {
		src = *fsrc
	}
	resp, err := http.Get(src)
	if err != nil {
		log.Fatalln(err)
	}
	defer func() { _ = resp.Body.Close() }()

	contents, err := io.ReadAll(resp.Body)
	if err != nil {
		log.Fatalln(err)
	}

	if err = json.Unmarshal(contents, &raw); err != nil {
		log.Fatalln(err)
	}

	for name := range raw {
		names = append(names, name)
	}
	sort.Strings(names)
}

func main() {
	var w bytes.Buffer
	_, _ = w.WriteString("// Code generated by \"")
	for i := 0; i < len(os.Args); i++ {
		if i > 0 {
			w.WriteByte(' ')
		}
		w.WriteString(os.Args[i])
	}
	_, _ = w.WriteString("\". DO NOT EDIT.\n\n")
	_, _ = w.WriteString("package htmlent\n\n")

	_, _ = w.WriteString("var (\n")

	_, _ = w.WriteString("__n2cp = map[string]rune{\n")
	for i := 0; i < len(names); i++ {
		_, _ = w.WriteString(`"`)
		_, _ = w.WriteString(names[i])
		_, _ = w.WriteString(`":`)
		_, _ = w.WriteString(fmt.Sprintf("0x%08x", raw[names[i]].Codepoints[0]))
		_, _ = w.WriteString(",\n")
	}
	_, _ = w.WriteString("}\n")

	_, _ = w.WriteString("__n2c = map[string]string{\n")
	for i := 0; i < len(names); i++ {
		_, _ = w.WriteString(`"`)
		_, _ = w.WriteString(names[i])
		_, _ = w.WriteString(`":`)
		_, _ = w.WriteString(fmt.Sprintf("0x%08x", raw[names[i]].Codepoints[0]))
		_, _ = w.WriteString(",\n")
	}
	_, _ = w.WriteString("}\n")

	_, _ = w.WriteString(")\n")

	source := w.Bytes()
	var (
		fmtSource []byte
		err       error
	)
	if fmtSource, err = format.Source(source); err != nil {
		return
	}

	fmt.Println(string(fmtSource))
}
